{"meta":{"title":"Fieshy's Blog","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2021-08-12T12:28:56.753Z","updated":"2021-08-12T12:28:56.753Z","comments":true,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"阿巴阿巴阿巴阿巴阿巴阿巴阿巴阿巴 阿巴阿巴阿巴阿巴阿巴阿巴阿巴阿巴 阿巴阿巴阿巴阿巴阿巴阿巴阿巴阿巴"},{"title":"所有标签","date":"2021-08-12T12:01:08.272Z","updated":"2021-08-12T12:01:08.272Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2021-08-12T12:28:24.185Z","updated":"2021-08-12T12:28:24.185Z","comments":true,"path":"mylist/index.html","permalink":"http://example.com/mylist/index.html","excerpt":"","text":""}],"posts":[{"title":"题解：CF1407D Discrete Centrifugal Jumps","slug":"题解：CF1407D-Discrete-Centrifugal-Jumps","date":"2021-08-12T07:13:32.000Z","updated":"2021-08-12T11:00:49.430Z","comments":true,"path":"2021/08/12/题解：CF1407D-Discrete-Centrifugal-Jumps/","link":"","permalink":"http://example.com/2021/08/12/%E9%A2%98%E8%A7%A3%EF%BC%9ACF1407D-Discrete-Centrifugal-Jumps/","excerpt":"","text":"题意简析 给你 $n$ 座楼，没座楼的高度为 $h_i$。 初始在第一座楼，你需要跳到第 $n$ 座楼上。 能从 $i$ 跳到 $j$ 需满足以下条件之一： $1. i = j + 1$ $2. \\min(h_i,h_j) &gt; \\max(h_{i+1},h_{i+2},…,h_{j-2},h_{j-1})$ $3. \\max(h_i,h_j) &lt; \\min(h_{i+1},h_{i+2},…,h_{j-2},h_{j-1})$ 问你最小需要跳几次？ $2\\le n \\le 3\\times 10^5$,$1\\le h_i \\le 10^9$。 分析&#8195;&#8195;显然，这是一道 dp 题。但是直接暴力枚举 $i,j$，和枚举区间最大值和最小值，复杂度为 $O(n^3)$。可能某些神仙能把它优化到 $O(n^2)$，但是本题仍不能过。考虑 $O(n\\log n)$ 的算法。 这里考虑单调栈。什么是单调栈？ 单调栈，是指一个栈中，所有的元素均满足一种单调性。它可以是升序，也可以是降序，只要满足单调皆可。 在这里，区间的最大值，最小值，都可以存到一个单调栈中，每次需要查找或更新时，将栈中的元素取出即可。这一复杂度为 $O(\\log n)$。就很神仙。 那么在本题中，我们可以开两个栈，分别为升序和降序，表示题意中最大值和最小值能跳跃的条件。方便规定，我们将栈顶元素最大表示为降序。记 $s$ 表示降序的单调栈，且 $s$ 中保存的元素是它在 $h$ 中的编号。 对于这种情况：假设我们当前枚举到了 $i$，让 $h_i$ 与栈顶 $h_{s_{tot}}$ 进行比较。如果 $h_i\\le h_{s_{tot}}$，违背了单调性，需要让 $tot=tot-1$，但是在这种情况，满足我们跳跃的第二种条件。因为单调性，所以 $h_{s_{tot-1}}\\le h_{s_{tot}}$，且 $h_{s_{tot}}$ 是 $[tot,i]$ 中的最大值，又已知 $h_i\\le h_{s_{tot}}$，只要$h_i\\not = h_{s_{tot}}$ 肯定满足 $\\min(h_i,h_{s_{tot-1}})&lt;\\max(h_{s_{tot}},…,h_{i-1})$，固有：$$dp_i=\\min(dp_i,dp_{s_{tot-1}}+1)$$ 升序同理。当然，最初$$dp_i=dp_{i-1}+1$$ 这样我们就轻松的解决了这道题。 总结其实也没啥好总结的。 用单调栈优化 dp。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;using namespace std;const int N = 3e5 + 7;;int s[N], dp[N], a[N], b[N];int tot1, tot2;inline int max(int x, int y)&#123;return x &gt; y ? x : y;&#125;inline int min(int x, int y)&#123;return x &lt; y ? x : y;&#125;inline int read()&#123; int x = 0, f = 1; char c = getchar(); while (!isdigit(c))&#123;if (c == &#x27;-&#x27;) f = -1; c = getchar();&#125; while (isdigit(c))&#123;x = (x &lt;&lt; 3) + (x &lt;&lt; 1) + c - &#x27;0&#x27;; c = getchar();&#125; return x * f;&#125;int main()&#123; int n = read(); for (int i = 1; i &lt;= n; i ++) s[i] = read(); memset(dp, 0x3f3f3f3f, sizeof(dp)); a[++ tot1] = 1, b[++ tot2] = 1, dp[1] = 0; for (int i = 2; i &lt;= n; i ++)&#123; dp[i] = dp[i - 1] + 1; while (tot1 &amp;&amp; s[i] &gt;= s[a[tot1]])&#123; if (s[i] != s[a[tot1]]) dp[i] = min(dp[i], dp[a[tot1 - 1]] + 1); tot1 --; &#125; while (tot2 &amp;&amp; s[i] &lt;= s[b[tot2]])&#123; if (s[i] != s[b[tot2]]) dp[i] = min(dp[i], dp[b[tot2 - 1]] + 1); tot2 --; &#125; a[++ tot1] = i, b[++ tot2] = i; &#125; printf(&quot;%d&quot;, dp[n]); return 0;&#125;","categories":[],"tags":[{"name":"OI/题解","slug":"OI-题解","permalink":"http://example.com/tags/OI-%E9%A2%98%E8%A7%A3/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-08-12T06:44:59.790Z","updated":"1985-10-26T08:15:00.000Z","comments":true,"path":"2021/08/12/hello-world/","link":"","permalink":"http://example.com/2021/08/12/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"OI/题解","slug":"OI-题解","permalink":"http://example.com/tags/OI-%E9%A2%98%E8%A7%A3/"}]}